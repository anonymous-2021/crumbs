------------------------------------------------------------
--
-- This Haskell script corresponds to the second use case of
-- the paper "Crumbs: Utilizing Functional Programming for
-- Hardware Trace Data Analysis" submitted to the DATE 2021.
--
-- It reads offline trace data generated by the MCDS of an
-- Infineon AURIX TC397 running a multicore application with
-- a spinlock to secure the access on a shared peripheral.
--
-- It calculates the acquisition and blocking time of the
-- spinlock variable from both cores.
--
------------------------------------------------------------

-- Library imports
import Trace
import Utils

-- Main entry
main = do
    -- Read offline trace data from file
    trace <- readTrace "traces/Lock_Profiling_16kB.ht"
    -- Filter trace according to CPU0 and calculate stats
    let c0 = gr $ fam CPU0 trace
    -- Filter trace according to CPU1 and calculate stats
    let c1 = gr $ fam CPU1 trace
    -- Print stats
    putStrLn $ "Core 0, Ac. Time [us]: " ++ (show $ c0.>fst)
    putStrLn $ "Core 1, Ac. Time [us]: " ++ (show $ c1.>fst)
    putStrLn $ "Core 0, Bl. Time [us]: " ++ (show $ c0.>snd)
    putStrLn $ "Core 1, Bl. Time [us]: " ++ (show $ c1.>snd)

-- Recalculate the list of tick tuples to microsecond tuples
gr :: [(Integer, Integer)] -> (Double, Double)
gr xs = ((toUs 150) . avg . gat . tc $ gc xs
        ,(toUs 150) . avg . gbt . tc $ gc xs)

-- Remove the first and last element of the given list
tc :: [a] -> [a]
tc = (tail . init)

-- Filter trace according to the given observation point
-- and map the trace messages to value and time tuples
fam :: ObservationPoint -> Trace -> [(Integer, Integer)]
fam _ [] = []
fam op (x:xs) | x |= Mem && x.>origin == op
                = (x.>time, x.>content.>dValue) : fam op xs
              | otherwise = fam op xs

-- Split the value and time tuples to independent lists
-- each representing one spinlock cycle
gc :: [(Integer, Integer)] -> [[(Integer, Integer)]]
gc [] = []
gc (x:xs) | x.>snd == 0 = gc' xs : gc xs
          | otherwise = gc xs
  where gc' [] = []
        gc' (y:ys) | y.>snd == 0 = [y]
                   | otherwise = y : gc' ys

-- Calculate the blocking time for each spinlock cycle
gbt :: [[(Integer, Integer)]] -> [Integer]
gbt [] = []
gbt (x:xs) = (x.>last.>fst - x.>init.>last.>fst) : gbt xs

-- Calculate the acquisition time for each spinlock cycle
gat :: [[(Integer, Integer)]] -> [Integer]
gat [] = []
gat (x:xs) = (x.>init.>last.>fst - x.>head.>fst) : gat xs