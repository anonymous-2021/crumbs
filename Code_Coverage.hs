------------------------------------------------------------

-- This Haskell script corresponds to the second use case of
-- the paper "Crumbs: Utilizing Functional Programming for
-- Hardware Trace Data Analysis" submitted to the RTNS 2021.
--
-- It reads offline trace data generated by the MCDS of an
-- Infineon AURIX TC397 running a function with randomized
-- execution paths.
--
-- It calculates the coverage of the executed execution
-- paths. The more traces are used for the calculation, the
-- higher the coverage will be, since each trace might
-- contain another randomly chosen execution path.
--
------------------------------------------------------------

-- Library imports
import Data.List
import Trace
import Utils

-- Start address of the code to be measured
fStart :: Address
fStart = 0x80000C5C

-- End address of the code to be measured
fEnd :: Address
fEnd = 0x80000E96

-- Main entry
main = do
    -- Number of up to 64 different offline traces used for
    -- the calulcation of the code coverage
    let num = 16
    -- Build filenames of offline trace data files
    let fn = "traces/Code_Coverage_Trace_"
    let files = map (\i -> fn ++ (show i) ++ ".ht") [1..num]
    -- Read offline trace data files
    traces <- mapM readTrace files
    -- Extract all executed address ranges from the traces
    let addrPairs = map (ga fStart fEnd) traces
    -- Calculate number of bytes executed
    let cvrd = pp addrPairs
    -- Calculate final code coverage result
    let res = cround $ (gr cvrd fStart fEnd) * 100
    -- Print result
    putStrLn $ "Coverage: " ++ (show res) ++ "%"

-- Calculate the coverage of the given 
-- executed address ranges
gr :: [(Integer, Integer)] -> Integer -> Integer -> Double
gr xs fs fe = (fRng - sDst - eDst - gaps) / fRng
            where
              gaps = fromInteger(gg xs)
              fRng = fromInteger(fe - fs)
              sDst = fromInteger(xs.>head.>fst - fs)
              eDst = max 0 $ fromInteger(fe - xs.>last.>snd)

-- Convert the list of address pairs of the different races
-- to one list of unique address pairs of executed address
-- ranges
pp :: [[(Integer, Integer)]] -> [(Integer, Integer)]
pp xs = (sort . nub . concat) xs

-- Convert the given trace to the executed address ranges
-- between (including) the given start and end address
ga :: Address -> Address -> Trace -> [(Integer, Integer)]
ga _ _ [] = []
ga fs fe (x:xs) | x |= IPT && a1 >= fs && a2 <= fe
                  = (a1, a2 + 4) : ga fs fe xs
                | otherwise = ga fs fe xs
                where
                    a1 = x.>content.>addr1
                    a2 = x.>content.>addr2

-- Calculate the amount of bytes not appearing in any of
-- the given address ranges (gaps)
gg :: [(Integer, Integer)] -> Integer
gg (_:[]) = 0
gg ((a, b):(c, d):xs) | b < c = (c - b) + gg ((c, d):xs)
                      | otherwise = gg ((c, d):xs)
