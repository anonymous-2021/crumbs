------------------------------------------------------------
--
-- This Haskell script corresponds to the first use case of
-- the paper "Crumbs: Utilizing Functional Programming for
-- Hardware Trace Data Analysis" submitted to the DATE 2021.
--
-- It reads offline trace data generated by the MCDS of an
-- Infineon AURIX TC397 running ErikaOS with 8 tasks.
--
-- It calculates the period, wcet, and wcrt of each task.
--
------------------------------------------------------------

-- Library imports
import qualified Safe as S
import Trace
import Utils

-- Main entry
main = do
  -- Addresses of the ORTI status array
  let addrs = [0x700001EC, 0x700001F0 .. 0x70000224]
    -- Read offline trace data from file
  tr <- readTrace "traces/ORTI_Trace_60s.ht"
  -- Calculate task set stats
  let res = map (getStats tr) addrs
  -- Remove task stats of inactive tasks
  -- (idle loop, startup, etc.)
  let flt = filter (\(x:_) -> x /= "0.0") res
  -- Print task set stats
  let hdrs = ["Period [ms]", "WCET [ms]", "WCRT [ms]"]
  mapM putStrLn $ table hdrs flt

-- Calculate task stats for a given trace
-- and the task's orti-address
getStats :: Trace -> Integer -> [String]
getStats t addr = map (\fx -> f1 $ fx $ f2) [gp, ge, gr]
                where
                  f1 = show . cround . toMs 150 . avg
                  f2 = S.initSafe . gi . gs $ fa t addr

-- Convert the time and task state tuples to single
-- task instances
gi :: [(Integer, Integer)] -> [[(Integer, Integer)]]
gi [] = []
gi (x:xs) | x.>snd == 3 = gi' xs : gi xs
          | otherwise = gi xs
          where gi' (x:y:xs) | x.>snd == 0 = (x.>fst,y.>fst) 
                               : gi' (y:xs)
                             | x.>snd == 3 = []
                             | otherwise = gi' (y:xs)
                gi' _ = []

-- Filter trace data according to the task's orti-address
fa :: Trace -> Integer -> Trace
fa [] _ = []
fa (x:xs) a | x |= Tim = x : fa xs a
            | x |= Mem && 
              x.>content.>dAddress == a = x : fa xs a
            | otherwise = fa xs a

-- Convert the given trace to time and task state tuples
gs :: Trace -> [(Integer, Integer)]
gs (x:y:xs) | x |= Mem && y |= Tim
              = (y.>time, x.>content.>dValue) : gs xs
            | not (x |= Mem) = gs (y:xs)
gs _ = []

-- Calculate periods of the given task instances
gp :: [[(Integer, Integer)]] -> [Integer]
gp (x:y:xs) = y.>head.>fst - x.>head.>fst : gp(y:xs)
gp _ = []

-- Calculate response times of the given task instances
gr :: [[(Integer, Integer)]] -> [Integer]
gr (x:xs) = x.>last.>snd - x.>head.>fst : gr xs
gr _ = []

-- Calculate execution times of the given task instances
ge :: [[(Integer, Integer)]] -> [Integer]
ge xs = map (\ys -> sum (map (\(s, e) -> e - s) ys)) xs